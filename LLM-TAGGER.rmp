<?xml version="1.0" encoding="UTF-8"?><process version="10.3.001">
  <context>
    <input/>
    <output/>
    <macros/>
  </context>
  <operator activated="true" class="process" compatibility="10.3.001" expanded="true" name="Process">
    <parameter key="logverbosity" value="init"/>
    <parameter key="random_seed" value="2001"/>
    <parameter key="send_mail" value="never"/>
    <parameter key="notification_email" value=""/>
    <parameter key="process_duration_for_mail" value="30"/>
    <parameter key="encoding" value="SYSTEM"/>
    <process expanded="true">
      <operator activated="true" class="time_series:generate_data_arima" compatibility="10.3.001" expanded="true" height="68" name="starter" width="90" x="45" y="85">
        <parameter key="name_of_new_time_series_attribute" value="starter"/>
        <enumeration key="coefficients_of_the_auto-regressive_terms"/>
        <enumeration key="coefficients_of_the_moving-average_terms"/>
        <parameter key="constant" value="0.0"/>
        <parameter key="standard_deviation_of_the_innovations" value="1.0"/>
        <parameter key="length" value="1000"/>
        <parameter key="use_local_random_seed" value="false"/>
        <parameter key="local_random_seed" value="1992"/>
      </operator>
      <operator activated="true" class="python_scripting:execute_python" compatibility="10.0.001" expanded="true" height="103" name="Install dependencies" width="90" x="179" y="34">
        <parameter key="script" value="import pandas&#10;import subprocess&#10;import sys&#10;import importlib&#10;&#10;# rm_main is a mandatory function,&#10;# the number of arguments has to be the number of input ports (can be none),&#10;# or the number of input ports plus one if &quot;use macros&quot; parameter is set&#10;# if you want to use macros, use this instead and check &quot;use macros&quot; parameter:&#10;# def rm_main(data, macros):&#10;def install_package(package):&#10;    try:&#10;        # Attempt to import the package, if it fails, install it&#10;        importlib.import_module(package)&#10;        print(f&quot;'{package}' is already installed.&quot;)&#10;    except ImportError:&#10;        print(f&quot;Installing '{package}' package...&quot;)&#10;        subprocess.check_call([sys.executable, &quot;-m&quot;, &quot;pip&quot;, &quot;install&quot;, package])&#10;&#10;def rm_main(data):&#10;    print('Hello, world!')&#10;    # output can be found in Log View&#10;    print(type(data))&#10;&#10;    # Example operation on the input data&#10;    data2 = pandas.DataFrame([&quot;PyQt5 - Installed&quot;, &quot;openpyxl - Installed&quot;])&#10;&#10;    # List of packages to install&#10;    packages = [&quot;PyQt5&quot;, &quot;openpyxl&quot;]&#10;&#10;    # Install each package&#10;    for package_name in packages:&#10;        install_package(package_name)&#10;&#10;    # Check and print installed packages and their versions&#10;    print(&quot;\nDependencies installed:&quot;)&#10;    subprocess.check_call([sys.executable, &quot;-m&quot;, &quot;pip&quot;, &quot;freeze&quot;])&#10;&#10;    # Display a message in a simple GUI window using PyQt5&#10;    try:&#10;        from PyQt5.QtWidgets import QApplication, QMessageBox&#10;        app = QApplication([])&#10;        msg_box = QMessageBox()&#10;        msg_box.setText(&quot;The 'PyQt5' and 'openpyxl' packages and their dependencies have been installed.&quot;)&#10;        msg_box.exec_()&#10;        return data, data2&#10;        sys.exit(app.exec_())&#10;    except Exception as e:&#10;        print(f&quot;An error occurred while trying to display the message: {e}&quot;)&#10;&#10;    # Connect 2 output ports to see the results&#10;    return data, data2&#10;&#10;# Example call to rm_main for testing purposes&#10;if __name__ == &quot;__main__&quot;:&#10;    test_data = pandas.DataFrame([1, 2, 3])&#10;    result = rm_main(test_data)&#10;    print(result)&#10;"/>
        <parameter key="notebook_cell_tag_filter" value=""/>
        <parameter key="use_default_python" value="true"/>
        <parameter key="package_manager" value="conda (anaconda)"/>
        <parameter key="use_macros" value="false"/>
      </operator>
      <operator activated="true" class="python_scripting:execute_python" compatibility="10.0.001" expanded="true" height="103" name="Set key" width="90" x="313" y="34">
        <parameter key="script" value="import pandas as pd&#10;import subprocess&#10;import sys&#10;import importlib&#10;import os&#10;from PyQt5.QtWidgets import QApplication, QFileDialog, QMessageBox, QInputDialog&#10;&#10;def save_api_key_to_file(key):&#10;    home_dir = os.path.expanduser(&quot;~&quot;)&#10;    key_file_path = os.path.join(home_dir, &quot;openai_api_key.txt&quot;)&#10;    with open(key_file_path, &quot;w&quot;) as key_file:&#10;        key_file.write(key)&#10;    return key_file_path&#10;&#10;def load_api_key_from_file():&#10;    home_dir = os.path.expanduser(&quot;~&quot;)&#10;    key_file_path = os.path.join(home_dir, &quot;openai_api_key.txt&quot;)&#10;    if os.path.exists(key_file_path):&#10;        with open(key_file_path, &quot;r&quot;) as key_file:&#10;            return key_file.read().strip()&#10;    return None&#10;&#10;def rm_main(data):&#10;    try:&#10;        # Create a PyQt5 application&#10;        app = QApplication([])&#10;        # Check if the OpenAI API key is already present in the environment variables&#10;        key, ok_pressed = QInputDialog.getText(None, &quot;OpenAI API Key&quot;, &quot;Enter your OpenAI API key:&quot;)&#10;        if ok_pressed and key:&#10;            save_api_key_to_file(key)&#10;            print(&quot;OpenAI API key saved to environment variables.&quot;)&#10;            &#10;            # Confirm that the key has been saved&#10;            msg_box = QMessageBox()&#10;            msg_box.setText(&quot;OpenAI API key has been saved.&quot;)&#10;            msg_box.exec_()&#10;            return data&#10;&#10;        else:&#10;            msg_box = QMessageBox()&#10;            msg_box.setText(&quot;No API key provided. Exiting.&quot;)&#10;            msg_box.exec_()&#10;&#10;            return data&#10;&#10;    except Exception as e:&#10;        print(f&quot;An error occurred: {e}&quot;)&#10;        msg_box = QMessageBox()&#10;        msg_box.setText(f&quot;An error occurred: {e}&quot;)&#10;        msg_box.exec_()&#10;        return None&#10;&#10;# Example call to rm_main for testing purposes&#10;if __name__ == &quot;__main__&quot;:&#10;    test_data = pd.DataFrame([1, 2, 3])&#10;    result = rm_main(test_data)&#10;    if result is not None:&#10;        print(&quot;Loaded data:&quot;)&#10;        print(result)&#10;"/>
        <parameter key="notebook_cell_tag_filter" value=""/>
        <parameter key="use_default_python" value="true"/>
        <parameter key="package_manager" value="conda (anaconda)"/>
        <parameter key="use_macros" value="false"/>
      </operator>
      <operator activated="true" breakpoints="after" class="python_scripting:execute_python" compatibility="10.0.001" expanded="true" height="103" name="Criteria processing" width="90" x="447" y="34">
        <parameter key="script" value="import time&#10;import pandas as pd&#10;import subprocess&#10;import sys&#10;import importlib&#10;import os&#10;from io import StringIO&#10;import requests&#10;import re&#10;import io&#10;from PyQt5.QtWidgets import QApplication, QFileDialog, QMessageBox, QInputDialog&#10;&#10;def csv_to_prompt(file):&#10;    if &quot;.csv&quot; not in file:&#10;        return &quot;Invalid file format. Please provide a CSV file.&quot;&#10;    df_main, df_sub = split_csv_to_types(file)&#10;    system_prompt = &quot;Act as an expert in the field of English. understand the main and sub types of given framework based on provided descriptions. user will provide chunck of text , generate response according criteria mentioned at the end.\n&quot;&#10;    main_type = df_main.loc[df_main.index[0], df_main.columns[0]]&#10;    main_type_description = df_main.loc[df_main.index[0], df_main.columns[0]]&#10;    framework = &quot;Framework main type: [&quot; + main_type + &quot;] &quot; + &quot;main type description: [&quot; + main_type_description + &quot;]\n&quot;&#10;    system_prompt += framework&#10;    for index, row in df_sub.iterrows():&#10;        sub_type = row[df_sub.columns[0]]&#10;        sub_type_description = row[df_sub.columns[1]]&#10;        system_prompt += &quot;Sub type: [&quot; + sub_type + &quot;] &quot; + &quot;Description: [&quot; + sub_type_description + &quot;]\n&quot;&#10;    system_prompt += framework&#10;    system_prompt += system_prompt&#10;&#10;    responsecriteria = '''&#10;Response criteria.&#10;Given a piece of text containing multiple clauses, your task is to split the text into individual clauses. Clauses are independent units of meaning that typically contain a subject and a predicate (verb). Clauses can be separated by punctuation marks such as commas, semicolons, colons, or conjunctions like &quot;and&quot;, &quot;but&quot;, &quot;or&quot;, etc. Some clauses may also be complex or compound sentences containing multiple phrases and clauses.&#10;Your objective is to develop a model that can accurately identify and extract these clauses from the text. The output should be a list of individual clauses, each representing a separate unit of meaning within the original text.&#10;  &#10;1. Breakdown the user text chunk into clauses. Given a piece of text containing multiple clauses, your task is to split the text into individual clauses. Clauses are independent units of meaning that typically contain a subject and a predicate (verb). Clauses can be separated by punctuation marks such as commas, semicolons, colons, or conjunctions like &quot;and&quot;, &quot;but&quot;, &quot;or&quot;, etc. Some clauses may also be complex or compound sentences containing multiple phrases and clauses.  accurately identify and extract these clauses from the text. The output should be a list of individual clauses.&#10;2. Tag each clause of the input chunk with sub type , according to the given sub types descriptions. &#10;3. a clause can have more than one tag.&#10;4. return an structured csv response that contain line number, clause,  the associated tags and justification of selecting tags.&#10;5. provide justification as 4th attribute of each clause in csv file.&#10;6. each string should be enclosed in double quotes.&#10;7. csv output should be enclosed in &lt;csv&gt; &lt;/csv&gt;.&#10;'''&#10;    system_prompt += responsecriteria&#10;    return system_prompt&#10;&#10;&#10;def load_data_from_file(file_path):&#10;    try:&#10;        with open(file_path, &quot;r&quot;) as file:&#10;            data = file.read()&#10;        return data&#10;    except FileNotFoundError:&#10;        return &quot;File not found.&quot;&#10;    except Exception as e:&#10;        return f&quot;An error occurred: {e}&quot;&#10;&#10;def fix_csv_file_using_gpt(key, text):&#10;    time.sleep(1)&#10;    # Set up the API endpoint and headers&#10;    url = f&quot;https://api.openai.com/v1/chat/completions&quot;&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {key}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;    }&#10;&#10;    # Remove backslashes from the input text and clean it&#10;&#10;    # Prepare the request body&#10;    body = {&#10;        &quot;model&quot;: &quot;gpt-4o&quot;,&#10;        &quot;messages&quot;: [&#10;            {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;User will provide csv data, csv contains two columns, fix the csv and also fix utf-8 issue. only reply csv contents of the file, formated between &lt;csv&gt; and &lt;/csv&gt; tags.&quot;},&#10;            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: text},&#10;        ],&#10;        &quot;temperature&quot;: 0,  # Control output randomness&#10;    }&#10;&#10;    print(&quot;SENDING REQUEST&quot;)&#10;&#10;    # Send the POST request to the OpenAI API&#10;    try:&#10;        response = requests.post(url, headers=headers, json=body, timeout=300)&#10;&#10;        # Check for successful response&#10;        response.raise_for_status()&#10;&#10;        # Get the response content from the first choice&#10;        print(response.json())&#10;        #save_to_text_file(filename_folder, filename + &quot;__&quot;, response.json())&#10;&#10;&#10;        reply = response.json()[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;        # Convert the response into a row of a DataFrame&#10;        csv_pattern = r&quot;&lt;csv&gt;(.*?)&lt;\/csv&gt;&quot;&#10;        csv_content_match = re.search(csv_pattern, reply, re.DOTALL)&#10;&#10;        if not csv_content_match:&#10;            raise ValueError(&quot;No CSV content found within &lt;csv&gt; tags.&quot;)&#10;        # Get the CSV content&#10;        csv_string =reply&#10;        start = csv_string.find('&lt;csv&gt;') + len('&lt;csv&gt;')&#10;        end = csv_string.find('&lt;/csv&gt;')&#10;&#10;        # Extract the CSV content&#10;        csv_content = csv_string[start:end].strip()&#10;&#10;        # Use io.StringIO to create a file-like object from the string&#10;        csv_data = io.StringIO(csv_content)&#10;&#10;        # Read the CSV content into a DataFrame&#10;        dfxx = pd.read_csv(csv_data)&#10;        '''&#10;        # Show a file dialog for the user to select a folder&#10;        folder_dialog = QFileDialog()&#10;        folder_dialog.setFileMode(QFileDialog.Directory)&#10;        folder_dialog.setOption(QFileDialog.ShowDirsOnly, True)&#10;        folder_dialog.setWindowTitle(&quot;Select Folder to Save CSV File&quot;)&#10;        if folder_dialog.exec_():&#10;            folder_path = folder_dialog.selectedFiles()[0]&#10;            print(f&quot;Folder selected: {folder_path}&quot;)&#10;&#10;            # Define the file path for saving the DataFrame&#10;            file_path = os.path.join(folder_path, &quot;output.txt&quot;)&#10;&#10;            # Save the CSV content to the file path&#10;            with open(file_path, &quot;w&quot;) as file:&#10;                file.write(csv_content)&#10;            print(f&quot;CSV content saved to {file_path}&quot;)&#10;&#10;            # Display a message box to confirm saving&#10;            msg_box = QMessageBox()&#10;            msg_box.setText(f&quot;CSV content saved successfully to '{file_path}'.&quot;)&#10;            msg_box.exec_()&#10;&#10;        else:&#10;            msg_box = QMessageBox()&#10;            msg_box.setText(&quot;No folder selected. Exiting.&quot;)&#10;            msg_box.exec_()&#10;            return None&#10;&#10;&#10;        # Convert the CSV content to a DataFrame&#10;        '''&#10;        return dfxx&#10;&#10;    except requests.exceptions.Timeout:&#10;        print(&quot;ANALYSIS: [NF-TIMEOUT]&quot;)&#10;        return None, &quot;[NF-TIMEOUT]&quot;&#10;&#10;    except requests.exceptions.HTTPError as e:&#10;        print(f&quot;HTTP Error: {e}&quot;)&#10;        return None, f&quot;[HTTP-ERROR: {e.response.status_code}]&quot;&#10;&#10;    except requests.exceptions.RequestException as e:&#10;        print(f&quot;Request Error: {e}&quot;)&#10;        return None, &quot;[REQUEST-ERROR]&quot;&#10;&#10;&#10;def save_api_key_to_file(key):&#10;    home_dir = os.path.expanduser(&quot;~&quot;)&#10;    key_file_path = os.path.join(home_dir, &quot;openai_api_key.txt&quot;)&#10;    with open(key_file_path, &quot;w&quot;) as key_file:&#10;        key_file.write(key)&#10;    return key_file_path&#10;&#10;def load_api_key_from_file():&#10;    home_dir = os.path.expanduser(&quot;~&quot;)&#10;    key_file_path = os.path.join(home_dir, &quot;openai_api_key.txt&quot;)&#10;    if os.path.exists(key_file_path):&#10;        with open(key_file_path, &quot;r&quot;) as key_file:&#10;            return key_file.read().strip()&#10;    return None&#10;&#10;def convert_csv_text_to_dataframe(csv_text):&#10;    try:&#10;        csv_io = StringIO(csv_text)&#10;        df = pd.read_csv(csv_io)&#10;        return df&#10;    except Exception as e:&#10;        print(f&quot;An error occurred: {e}&quot;)&#10;        return None&#10;&#10;def load_csv_with_fallback(file_path):&#10;    try:&#10;        # Try to read the CSV file with utf-8 encoding and error handling&#10;        df = pd.read_csv(file_path, encoding='utf-8', errors='replace')  # or errors='ignore'&#10;        print(&quot;File loaded successfully with utf-8 encoding.&quot;)&#10;        return df&#10;    except Exception as e:&#10;        print(f&quot;An error occurred with utf-8 encoding: {e}&quot;)&#10;        try:&#10;            # If utf-8 encoding fails, try with ISO-8859-1 encoding&#10;            df = pd.read_csv(file_path, encoding='ISO-8859-1')&#10;            print(&quot;File loaded successfully with ISO-8859-1 encoding.&quot;)&#10;            return df&#10;        except Exception as e:&#10;            print(f&quot;An error occurred with ISO-8859-1 encoding: {e}&quot;)&#10;            return None&#10;&#10;&#10;def rm_main(data):&#10;    try:&#10;        # Create a PyQt5 application&#10;        app = QApplication([])&#10;        # Check if the OpenAI API key is already present in the environment variables&#10;        key = load_api_key_from_file()&#10;        # Show a file dialog for the user to select a CSV file&#10;        file_dialog = QFileDialog()&#10;        file_dialog.setWindowTitle(&quot;Select Criteria CSV File&quot;)&#10;        file_dialog.setNameFilter(&quot;CSV Files (*.csv)&quot;)&#10;        if file_dialog.exec_():&#10;            file_path = file_dialog.selectedFiles()[0]&#10;            print(f&quot;File selected: {file_path}&quot;)&#10;&#10;            # Load the data from the selected file using pandas&#10;            criteria_data = load_csv_with_fallback(file_path)&#10;            print(f&quot;Data loaded from {file_path}:\n{criteria_data}&quot;)&#10;            &#10;            # Display a message box to confirm data loading&#10;            msg_box = QMessageBox()&#10;            msg_box.setText(f&quot;Data loaded successfully from '{file_path}'.&quot;)&#10;            msg_box.exec_()&#10;            text_data = load_data_from_file(file_path)&#10;            criteria_data = fix_csv_file_using_gpt(key, text_data)&#10;            #criteria_data = convert_csv_text_to_dataframe(fixed_csv)&#10;            return criteria_data&#10;        else:&#10;            msg_box = QMessageBox()&#10;            msg_box.setText(&quot;No file selected. Exiting.&quot;)&#10;            msg_box.exec_()&#10;            return None&#10;&#10;    except Exception as e:&#10;        print(f&quot;An error occurred: {e}&quot;)&#10;        msg_box = QMessageBox()&#10;        msg_box.setText(f&quot;An error occurred: {e}&quot;)&#10;        msg_box.exec_()&#10;        return None&#10;&#10;# Example call to rm_main for testing purposes&#10;if __name__ == &quot;__main__&quot;:&#10;    test_data = pd.DataFrame([1, 2, 3])&#10;    result = rm_main(test_data)&#10;    if result is not None:&#10;        print(&quot;Loaded data:&quot;)&#10;        print(result)&#10;"/>
        <parameter key="notebook_cell_tag_filter" value=""/>
        <parameter key="use_default_python" value="true"/>
        <parameter key="package_manager" value="conda (anaconda)"/>
        <parameter key="use_macros" value="false"/>
      </operator>
      <operator activated="true" breakpoints="after" class="python_scripting:execute_python" compatibility="10.0.001" expanded="true" height="103" name="Text processing" width="90" x="581" y="34">
        <parameter key="script" value="import pandas as pd&#10;import subprocess&#10;import sys&#10;import importlib&#10;import os&#10;import time&#10;import requests&#10;import io&#10;import re&#10;import pandas as pd&#10;from io import StringIO &#10;from PyQt5.QtWidgets import QApplication, QFileDialog, QMessageBox, QInputDialog&#10;&#10;def save_to_file(file_name, content):&#10;    home_dir = os.path.expanduser(&quot;~&quot;)&#10;    file_path = os.path.join(home_dir, file_name)&#10;    with open(file_path, &quot;w&quot;) as file:&#10;        file.write(content)&#10;    return file_path&#10;&#10;def load_from_file(file_name):&#10;    home_dir = os.path.expanduser(&quot;~&quot;)&#10;    file_path = os.path.join(home_dir, file_name)&#10;    if os.path.exists(file_path):&#10;        with open(file_path, &quot;r&quot;) as file:&#10;            return file.read().strip()&#10;    return None&#10;&#10;def load_data_from_file(file_path):&#10;    try:&#10;        with open(file_path, &quot;r&quot;) as file:&#10;            data = file.read()&#10;        return data&#10;    except FileNotFoundError:&#10;        return &quot;File not found.&quot;&#10;    except Exception as e:&#10;        return f&quot;An error occurred: {e}&quot;&#10;&#10;def load_csv_data_from_file(file_path):&#10;    # Load the CSV file into a DataFrame&#10;    df = pd.read_csv(file_path)&#10;    &#10;    # Select the second and third columns&#10;    new_df = df.iloc[:, [0,1,2]]&#10;    &#10;    # Rename the columns&#10;    new_df.columns = ['serial number','row', 'tag']&#10;    &#10;    &#10;    return new_df&#10;&#10;def fix_csv_file_using_gpt(key,option, text):&#10;    time.sleep(1)&#10;    # Set up the API endpoint and headers&#10;    url = f&quot;https://api.openai.com/v1/chat/completions&quot;&#10;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {key}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;    }&#10;&#10;    # Remove backslashes from the input text and clean it&#10;&#10;    conditions = &quot;&quot;&quot;Ensure that each field in the CSV is properly enclosed in quotes if it contains line breaks or commas. Here’s how you can fix this:&#10;1. **Escape Quotes and Commas**: Ensure any quotes within the text are escaped properly.&#10;2. **Use Double Quotes for Fields with Commas or Line Breaks**: Enclose any field with commas or line breaks in double quotes.&#10;&quot;&quot;&quot;&#10;&#10;    clause_def=&quot;&quot;&quot;A clause is a group of words that contains a subject and a predicate. It is a key part of sentence structure. Clauses can be independent or dependent. An independent clause can stand alone as a complete sentence and expresses a complete thought. Example: &quot;She reads books.&quot; A dependent clause cannot stand alone and needs an independent clause to complete its meaning. It often starts with words like &quot;because,&quot; &quot;although,&quot; or &quot;if.&quot; Example: &quot;because she enjoys learning.&quot; Recognize and extract these clauses based on their subject-predicate structure.&quot;&quot;&quot;&#10;    sentence_def=&quot;&quot;&quot;A sentence is a group of words that expresses a complete thought. It starts with a capital letter and ends with a punctuation mark, such as a period, exclamation mark, or question mark. A sentence must contain at least one subject (the person or thing the sentence is about) and one predicate (what the subject is doing or what is being said about the subject). Example: &quot;The cat sat on the mat.&quot; Identify and separate these complete thoughts to split the text into sentences.&quot;&quot;&quot;&#10;    para_def = &quot;&quot;&quot;A paragraph is a distinct section of writing that focuses on a single idea or topic. It begins on a new line and is typically indented or separated by a space from other paragraphs. A paragraph contains one or more sentences that develop a specific point or argument. The first sentence often introduces the main idea, followed by supporting sentences that provide details, examples, or explanations. Example: &quot;The cat sat on the mat. It was a sunny day, and the warmth of the sun made the mat a perfect spot for a nap.&quot; Identify and separate these sections to split the text into paragraphs.&quot;&quot;&quot;&#10;&#10;    items = [&quot;Clause&quot;, &quot;Sentence&quot;, &quot;Paragraph&quot;]&#10;&#10;&#10;    selected = &quot;&quot;&#10;    if &quot;Sentence&quot; in option:&#10;        selected = sentence_def&#10;&#10;    if &quot;Clause&quot; in option:&#10;        selected = clause_def&#10;&#10;    if &quot;Paragraph&quot; in option:&#10;        selected = para_def&#10;&#10;    # Prepare the request body&#10;    body = {&#10;        &quot;model&quot;: &quot;gpt-4o&quot;,&#10;        &quot;messages&quot;: [&#10;            {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;User will provide text data, understand the text and split it into &quot;+option+&quot;s.\n&quot;+selected+&quot;\n. Finally, convert it into csv format and also fix utf-8 issue.&quot;+conditions+&quot;. only reply csv contents, formated between &lt;csv&gt; and &lt;/csv&gt; tags.&quot;},&#10;            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: text},&#10;        ],&#10;        &quot;temperature&quot;: 0,  # Control output randomness&#10;    }&#10;&#10;    print(&quot;SENDING REQUEST&quot;)&#10;&#10;    # Send the POST request to the OpenAI API&#10;    try:&#10;        response = requests.post(url, headers=headers, json=body, timeout=300)&#10;&#10;        # Check for successful response&#10;        response.raise_for_status()&#10;&#10;        # Get the response content from the first choice&#10;        print(response.json())&#10;        #save_to_text_file(filename_folder, filename + &quot;__&quot;, response.json())&#10;&#10;&#10;        reply = response.json()[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;        # Convert the response into a row of a DataFrame&#10;        csv_pattern = r&quot;&lt;csv&gt;(.*?)&lt;\/csv&gt;&quot;&#10;        csv_content_match = re.search(csv_pattern, reply, re.DOTALL)&#10;&#10;        if not csv_content_match:&#10;            raise ValueError(&quot;No CSV content found within &lt;csv&gt; tags.&quot;)&#10;        # Get the CSV content&#10;        csv_string =reply&#10;        start = csv_string.find('&lt;csv&gt;') + len('&lt;csv&gt;')&#10;        end = csv_string.find('&lt;/csv&gt;')&#10;&#10;        # Extract the CSV content&#10;        csv_content = csv_string[start:end].strip()&#10;&#10;        # Use io.StringIO to create a file-like object from the string&#10;        csv_data = io.StringIO(csv_content)&#10;&#10;        # Read the CSV content into a DataFrame&#10;        dfxx = pd.read_csv(csv_data)&#10;        '''&#10;        # Show a file dialog for the user to select a folder&#10;        folder_dialog = QFileDialog()&#10;        folder_dialog.setFileMode(QFileDialog.Directory)&#10;        folder_dialog.setOption(QFileDialog.ShowDirsOnly, True)&#10;        folder_dialog.setWindowTitle(&quot;Select Folder to Save CSV File&quot;)&#10;        if folder_dialog.exec_():&#10;            folder_path = folder_dialog.selectedFiles()[0]&#10;            print(f&quot;Folder selected: {folder_path}&quot;)&#10;&#10;            # Define the file path for saving the DataFrame&#10;            file_path = os.path.join(folder_path, &quot;output.txt&quot;)&#10;&#10;            # Save the CSV content to the file path&#10;            with open(file_path, &quot;w&quot;) as file:&#10;                file.write(csv_content)&#10;            print(f&quot;CSV content saved to {file_path}&quot;)&#10;&#10;            # Display a message box to confirm saving&#10;            msg_box = QMessageBox()&#10;            msg_box.setText(f&quot;CSV content saved successfully to '{file_path}'.&quot;)&#10;            msg_box.exec_()&#10;            return dfxx&#10;&#10;        else:&#10;            msg_box = QMessageBox()&#10;            msg_box.setText(&quot;No folder selected. Exiting.&quot;)&#10;            msg_box.exec_()&#10;            return None&#10;        '''&#10;        return dfxx&#10;    except requests.exceptions.Timeout:&#10;        print(&quot;ANALYSIS: [NF-TIMEOUT]&quot;)&#10;        return None, &quot;[NF-TIMEOUT]&quot;&#10;&#10;    except requests.exceptions.HTTPError as e:&#10;        print(f&quot;HTTP Error: {e}&quot;)&#10;        return None, f&quot;[HTTP-ERROR: {e.response.status_code}]&quot;&#10;&#10;    except requests.exceptions.RequestException as e:&#10;        print(f&quot;Request Error: {e}&quot;)&#10;        return None, &quot;[REQUEST-ERROR]&quot;&#10;&#10;&#10;&#10;def select_and_return_text_data():&#10;    file_dialog = QFileDialog()&#10;    file_dialog.setWindowTitle(&quot;Select text&quot;)&#10;    file_dialog.setNameFilter(&quot;CSV and Text Files (*.csv *.txt)&quot;)&#10;    type=&quot;&quot;&#10;    if file_dialog.exec_():&#10;        file_path = file_dialog.selectedFiles()[0]&#10;        &#10;        if file_path.endswith('.txt'):&#10;&#10;            print(f&quot;File selected: {file_path}&quot;)&#10;            # Load the data from the selected file using pandas&#10;            text_data = load_data_from_file(file_path)        &#10;            # Display a message box to confirm data loading&#10;            type=&quot;txt&quot;&#10;        if file_path.endswith('.csv'):&#10;&#10;            print(f&quot;File selected: {file_path}&quot;)&#10;            # Load the data from the selected file using pandas&#10;            text_data = load_csv_data_from_file(file_path)        &#10;            # Display a message box to confirm data loading&#10;            type=&quot;csv&quot;&#10;&#10;        msg_box = QMessageBox()&#10;        msg_box.setText(f&quot;Data loaded successfully from '{file_path}'.&quot;)&#10;        msg_box.exec_()&#10;        return text_data,type&#10;    else:&#10;        msg_box = QMessageBox()&#10;        msg_box.setText(&quot;No file selected. Exiting.&quot;)&#10;        msg_box.exec_()&#10;        return None&#10;&#10;def load_api_key_from_file():&#10;    home_dir = os.path.expanduser(&quot;~&quot;)&#10;    key_file_path = os.path.join(home_dir, &quot;openai_api_key.txt&quot;)&#10;    if os.path.exists(key_file_path):&#10;        with open(key_file_path, &quot;r&quot;) as key_file:&#10;            return key_file.read().strip()&#10;    return None&#10;&#10;def get_option_value():&#10;            # Prompt the user for the option selection&#10;    items = [&quot;Clause&quot;, &quot;Sentence&quot;, &quot;Paragraph&quot;]&#10;    item, ok_pressed = QInputDialog.getItem(None, &quot;Select Option&quot;, &quot;Choose an option:&quot;, items, 0, False)&#10;    if ok_pressed and item:&#10;        return item&#10;    else:&#10;        return &quot;Sentence&quot;&#10;&#10;&#10;def rm_main(data):&#10;    try:&#10;        # Create a PyQt5 application&#10;        app = QApplication([])&#10;        &#10;        # Prompt the user for the OpenAI API key&#10;        key = load_api_key_from_file()&#10;        option = get_option_value()&#10;        file_text,type = select_and_return_text_data()&#10;        if type==&quot;txt&quot;:&#10;            text_data = fix_csv_file_using_gpt(key, option, file_text)&#10;        else:&#10;            text_data = file_text&#10;        return data,text_data&#10;&#10;&#10;    except Exception as e:&#10;        print(f&quot;An error occurred: {e}&quot;)&#10;        msg_box = QMessageBox()&#10;        msg_box.setText(f&quot;An error occurred: {e}&quot;)&#10;        msg_box.exec_()&#10;        return None&#10;&#10;# Example call to rm_main for testing purposes&#10;if __name__ == &quot;__main__&quot;:&#10;    test_data = pd.DataFrame([1, 2, 3])&#10;    result = rm_main(test_data)&#10;    if result is not None:&#10;        print(&quot;Loaded data:&quot;)&#10;        print(result)&#10;"/>
        <parameter key="notebook_cell_tag_filter" value=""/>
        <parameter key="use_default_python" value="true"/>
        <parameter key="package_manager" value="conda (anaconda)"/>
        <parameter key="use_macros" value="false"/>
      </operator>
      <operator activated="true" class="python_scripting:execute_python" compatibility="10.0.001" expanded="true" height="124" name="Apply criteria" width="90" x="715" y="34">
        <parameter key="script" value="import pandas as pd&#10;import os&#10;import requests&#10;import time&#10;import re&#10;import pickle&#10;import json&#10;from io import StringIO&#10;from PyQt5.QtWidgets import QApplication, QFileDialog&#10;&#10;&#10;def json_to_dataframe(json_string):&#10;    data = json.loads(json_string)&#10;    response_data = data.get(&quot;response&quot;, [])&#10;    df = pd.DataFrame(response_data)&#10;    return df&#10;&#10;&#10;def textcleaner(input_string):&#10;    cleaned_string = re.sub(r'[^a-zA-Z0-9\s-():{}\[\]]', '', input_string)&#10;    print(cleaned_string)&#10;    return cleaned_string&#10;&#10;&#10;def save_to_text_file(path, filename, text):&#10;    dfx = json_to_dataframe(text)&#10;    dfx.to_csv(os.path.join(path, filename + '.csv'), index=False)&#10;&#10;&#10;def save_to_text_file2(df, path, filename, text):&#10;    dfx = df&#10;    dfx.to_csv(os.path.join(path, filename + '.csv'), index=False)&#10;&#10;&#10;def df_to_text(df):&#10;    csv_content = df.to_csv(index=False)&#10;    return csv_content&#10;&#10;&#10;def process_text_files(system_prompt, input_text, api_key):&#10;    time.sleep(3)&#10;    localmodelname = &quot;gpt-4o&quot;&#10;    url = f&quot;https://api.openai.com/v1/chat/completions&quot;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {api_key}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;    }&#10;    cleaned_text = df_to_text(input_text)&#10;    body = {&#10;        &quot;model&quot;: localmodelname,&#10;        &quot;messages&quot;: [&#10;            {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_prompt},&#10;            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: cleaned_text},&#10;        ],&#10;        &quot;temperature&quot;: 0,&#10;    }&#10;    print(&quot;SENDING REQUEST&quot;)&#10;    try:&#10;        response = requests.post(url, headers=headers, json=body, timeout=300)&#10;        response.raise_for_status()&#10;        print(response.json())&#10;        reply = response.json()[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;        csv_pattern = r&quot;&lt;csv&gt;(.*?)&lt;\/csv&gt;&quot;&#10;        csv_content_match = re.search(csv_pattern, reply, re.DOTALL)&#10;        if not csv_content_match:&#10;            raise ValueError(&quot;No CSV content found within &lt;csv&gt; tags.&quot;)&#10;        csv_content = csv_content_match.group(1).strip()&#10;        csv_io = StringIO(csv_content)&#10;        df = pd.read_csv(csv_io)&#10;        return df, reply&#10;    except requests.exceptions.Timeout:&#10;        print(&quot;ANALYSIS: [NF-TIMEOUT]&quot;)&#10;        return None, &quot;[NF-TIMEOUT]&quot;&#10;    except requests.exceptions.HTTPError as e:&#10;        print(f&quot;HTTP Error: {e}&quot;)&#10;        return None, f&quot;[HTTP-ERROR: {e.response.status_code}]&quot;&#10;    except requests.exceptions.RequestException as e:&#10;        print(f&quot;Request Error: {e}&quot;)&#10;        return None, &quot;[REQUEST-ERROR]&quot;&#10;&#10;&#10;def process_csv(file_path):&#10;    # Load the CSV file into a DataFrame&#10;    df = file_path&#10;&#10;    # Select the second and third columns&#10;    new_df = df.iloc[:, [0, 1, 2]]&#10;&#10;    # Rename the columns&#10;    new_df.columns = ['serial number', 'row', 'tag']&#10;&#10;    # Convert the DataFrame to a CSV string&#10;    csv_string = new_df.to_csv(index=False)&#10;&#10;    return csv_string&#10;&#10;&#10;def process_text_files_csv(system_prompt, input_text, api_key):&#10;    time.sleep(3)&#10;    localmodelname = &quot;gpt-4o&quot;&#10;    url = f&quot;https://api.openai.com/v1/chat/completions&quot;&#10;    headers = {&#10;        &quot;Authorization&quot;: f&quot;Bearer {api_key}&quot;,&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;    }&#10;    cleaned_text = process_csv(input_text)&#10;    body = {&#10;        &quot;model&quot;: localmodelname,&#10;        &quot;messages&quot;: [&#10;            {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: system_prompt},&#10;            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: cleaned_text},&#10;        ],&#10;        &quot;temperature&quot;: 0,&#10;    }&#10;    print(&quot;SENDING REQUEST&quot;)&#10;    try:&#10;        response = requests.post(url, headers=headers, json=body, timeout=300)&#10;        response.raise_for_status()&#10;        print(response.json())&#10;        reply = response.json()[&quot;choices&quot;][0][&quot;message&quot;][&quot;content&quot;]&#10;        csv_pattern = r&quot;&lt;csv&gt;(.*?)&lt;\/csv&gt;&quot;&#10;        csv_content_match = re.search(csv_pattern, reply, re.DOTALL)&#10;        if not csv_content_match:&#10;            raise ValueError(&quot;No CSV content found within &lt;csv&gt; tags.&quot;)&#10;        csv_content = csv_content_match.group(1).strip()&#10;        csv_io = StringIO(csv_content)&#10;        df = pd.read_csv(csv_io)&#10;        return df, reply&#10;    except requests.exceptions.Timeout:&#10;        print(&quot;ANALYSIS: [NF-TIMEOUT]&quot;)&#10;        return None, &quot;[NF-TIMEOUT]&quot;&#10;    except requests.exceptions.HTTPError as e:&#10;        print(f&quot;HTTP Error: {e}&quot;)&#10;        return None, f&quot;[HTTP-ERROR: {e.response.status_code}]&quot;&#10;    except requests.exceptions.RequestException as e:&#10;        print(f&quot;Request Error: {e}&quot;)&#10;        return None, &quot;[REQUEST-ERROR]&quot;&#10;&#10;&#10;def select_input(df, macros):&#10;    input = macros['input']&#10;    return input&#10;&#10;&#10;def get_files_from_folder(folder):&#10;    file_list = []&#10;    for root, dirs, files in os.walk(folder):&#10;        for file in files:&#10;            file_list.append(os.path.join(root, file))&#10;    return file_list&#10;&#10;&#10;def list_to_dataframe(data_list):&#10;    df = pd.DataFrame(data_list, columns=['data'])&#10;    return df&#10;&#10;&#10;def get_text_contents(file_list):&#10;    text_contents = []&#10;    with open(file_list, 'r') as f:&#10;        text_contents.append(f.read())&#10;    return str(text_contents)&#10;&#10;&#10;def split_csv_to_types(inpdf):&#10;    df = inpdf&#10;    df_first = df.iloc[:2]&#10;    df_first.columns = df_first.iloc[0]&#10;    df_first = df_first[1:]&#10;    df_rest = df.iloc[2:]&#10;    df_rest.columns = df_rest.iloc[0]&#10;    df_rest = df_rest[1:]&#10;    return df_first, df_rest&#10;&#10;&#10;def csv_to_prompt(inpdf):&#10;    df_main, df_sub = split_csv_to_types(inpdf)&#10;    system_prompt = &quot;Act as an expert in the field of English. understand the main and sub types of given framework based on provided descriptions. user will provide rows of text in a csv format , generate response according criteria mentioned at the end.\n&quot;&#10;    main_type = df_main.loc[df_main.index[0], df_main.columns[0]]&#10;    main_type_description = df_main.loc[df_main.index[0], df_main.columns[0]]&#10;    framework = &quot;Framework main type: [&quot; + main_type + &quot;] &quot; + &quot;main type description: [&quot; + main_type_description + &quot;]\n&quot;&#10;    system_prompt += framework&#10;    for index, row in df_sub.iterrows():&#10;        sub_type = row[df_sub.columns[0]]&#10;        sub_type_description = row[df_sub.columns[1]]&#10;        system_prompt += &quot;Sub type: [&quot; + sub_type + &quot;] &quot; + &quot;Description: [&quot; + sub_type_description + &quot;]\n&quot;&#10;    system_prompt += framework&#10;    system_prompt += system_prompt&#10;    responsecriteria = '''&#10;Response criteria.  &#10;&#10;1. Tag each row of the input chunk with sub type , according to the given sub types descriptions. &#10;2. a row can have more than one tag or no tag.&#10;3. return an structured csv response that contain line number, input row,  the associated tags and justification of selecting tags.&#10;4. provide justification as 4th attribute in csv file.&#10;5. each string should be enclosed in double quotes.&#10;&#10;6. Ensure that each field in the CSV is properly enclosed in quotes if it contains line breaks or commas. Here’s how you can fix this:&#10;**Escape Quotes and Commas**: Ensure any quotes within the text are escaped properly.&#10;**Use Double Quotes for Fields with Commas or Line Breaks**: Enclose any field with commas or line breaks in double quotes.&#10;**Do not use comma**: only use comma for csv formating, replace other commas to semicolan.&#10;&#10;7. csv output should be enclosed in &lt;csv&gt; &lt;/csv&gt;.&#10;&#10;&#10;'''&#10;&#10;    system_prompt += responsecriteria&#10;    return system_prompt&#10;&#10;&#10;def csv_to_prompt_for_csv(inpdf):&#10;    df_main, df_sub = split_csv_to_types(inpdf)&#10;    system_prompt = &quot;Act as an expert in the field of English. understand the main and sub types of given framework based on provided descriptions. user will provide structured csv data. csv contains three column, first is the \&quot;Line Number\&quot; indicating order , second is the \&quot;Input Row\&quot; indicating the text required to be processed and third is the \&quot;Associated Tags\&quot;. For each row tagged as the main type under \&quot;Associated Tags\&quot; column, generate response according criteria mentioned at the end.\n&quot;&#10;    main_type = df_main.loc[df_main.index[0], df_main.columns[0]]&#10;    main_type_description = df_main.loc[df_main.index[0], df_main.columns[0]]&#10;    framework = &quot;Framework main type: [&quot; + main_type + &quot;] &quot; + &quot;main type description: [&quot; + main_type_description + &quot;]\n&quot;&#10;    system_prompt += framework&#10;    for index, row in df_sub.iterrows():&#10;        sub_type = row[df_sub.columns[0]]&#10;        sub_type_description = row[df_sub.columns[1]]&#10;        system_prompt += &quot;Sub type: [&quot; + sub_type + &quot;] &quot; + &quot;Description: [&quot; + sub_type_description + &quot;]\n&quot;&#10;    system_prompt += framework&#10;    system_prompt += system_prompt&#10;    responsecriteria = '''&#10;Response criteria.  &#10;&#10;1. first column name will be \&quot;Line Number\&quot; indicating order , second column will be \&quot;Input Row\&quot; indicating the text required to be processed and third column name will be \&quot;Associated Tags\&quot;.&#10;2. Keep associated tag in 3rd column.&#10;3. Assign sub type Tag for each row in 4th column if associated tag is present in 3rd column.  &#10;4. each row containing main type tag in 3th column should be tagged with at least one of the sub type in 4th column.&#10;5. a row can have one or more than one sub type tag in the 4th column.&#10;6. return an structured csv response that contain line number, input row,  the associated tags and justification of selecting tags.&#10;7. provide justification as 5th attribute in csv file.&#10;8. each string should be enclosed in double quotes.&#10;&#10;9. Ensure that each field in the CSV is properly enclosed in quotes if it contains line breaks or commas. Here’s how you can fix this:&#10;**Escape Quotes and Commas**: Ensure any quotes within the text are escaped properly.&#10;**Use Double Quotes for Fields with Commas or Line Breaks**: Enclose any field with commas or line breaks in double quotes.&#10;**Do not use comma**: only use comma for csv formating, replace other commas to semicolan.&#10;&#10;10. csv output should be enclosed in &lt;csv&gt; &lt;/csv&gt;.&#10;&#10;&#10;'''&#10;&#10;    system_prompt += responsecriteria&#10;    return system_prompt&#10;&#10;&#10;def generate_prompt_from_dataframe(df):&#10;    text_contents = []&#10;    text_contents.append(csv_to_prompt(df))&#10;    return text_contents&#10;&#10;&#10;def generate_prompt_from_dataframe_csv(df):&#10;    text_contents = []&#10;    text_contents.append(csv_to_prompt_for_csv(df))&#10;    return text_contents&#10;&#10;&#10;def loadpromptsfromcriteriapath(criteriapath):&#10;    file_list = get_files_from_folder(criteriapath)&#10;    text_contents = []&#10;    file_names = []&#10;    for file in file_list:&#10;        if &quot;.csv&quot; in file:&#10;            text_contents.append(csv_to_prompt(file))&#10;            file_names.append(os.path.splitext(os.path.basename(file))[0])&#10;    return file_names, text_contents&#10;&#10;&#10;def save_data_and_macros(path, data, macros):&#10;    temp_folder = path&#10;    if not os.path.exists(temp_folder):&#10;        os.makedirs(temp_folder)&#10;    data_file = os.path.join(temp_folder, &quot;data.pkl&quot;)&#10;    with open(data_file, &quot;wb&quot;) as file:&#10;        pickle.dump(data, file)&#10;    macros_file = os.path.join(temp_folder, &quot;macros.pkl&quot;)&#10;    with open(macros_file, &quot;wb&quot;) as file:&#10;        pickle.dump(macros, file)&#10;&#10;&#10;def load_api_key_from_file():&#10;    home_dir = os.path.expanduser(&quot;~&quot;)&#10;    key_file_path = os.path.join(home_dir, &quot;openai_api_key.txt&quot;)&#10;    if os.path.exists(key_file_path):&#10;        with open(key_file_path, &quot;r&quot;) as key_file:&#10;            return key_file.read().strip()&#10;    return None&#10;&#10;&#10;def save_dataframes_to_folder(dft1, dft2):&#10;    try:&#10;        folder_path = &quot;D:/RMFLOWS&quot;&#10;&#10;        # Save the first dataframe&#10;        dft1_path = os.path.join(folder_path, &quot;criteria.csv&quot;)&#10;        dft1.to_csv(dft1_path, index=False)&#10;&#10;        # Save the second dataframe&#10;        dft2_path = os.path.join(folder_path, &quot;text.csv&quot;)&#10;        dft2.to_csv(dft2_path, index=False)&#10;    except Exception as e:&#10;        print(&quot;Folder not present&quot;)&#10;&#10;def rearrange_df(df):&#10;    # Ensure the dataframe has at least 5 columns&#10;    if len(df.columns) &lt; 5:&#10;        raise ValueError(&quot;DataFrame must have at least 5 columns&quot;)&#10;&#10;    # Swap the 3rd and 4th columns&#10;    df.iloc[:, [2, 3]] = df.iloc[:, [3, 2]].values&#10;&#10;    # Rename the columns&#10;    df.columns.values[2] = &quot;Associated Tags&quot;&#10;    df.columns.values[3] = &quot;Parent Tags&quot;&#10;&#10;    return df&#10;&#10;def rm_main(criteria, text):&#10;    save_dataframes_to_folder(criteria, text)&#10;    if text.shape[1] == 3 and text.columns[-1] == 'tag':&#10;        systemprompts = generate_prompt_from_dataframe_csv(criteria)&#10;        key = load_api_key_from_file()&#10;        system_prompt = systemprompts[0]&#10;        returndf, convtxt = process_text_files_csv(system_prompt, text, key)&#10;        returndf=rearrange_df(returndf)&#10;    else:&#10;        systemprompts = generate_prompt_from_dataframe(criteria)&#10;        key = load_api_key_from_file()&#10;        system_prompt = systemprompts[0]&#10;        returndf, convtxt = process_text_files(system_prompt, text, key)&#10;&#10;    # Initialize PyQt5 application&#10;    app = QApplication([])&#10;    folder_selected = QFileDialog.getExistingDirectory(None, &quot;Select Folder to Save CSV&quot;)&#10;&#10;    if folder_selected:&#10;        save_path = os.path.join(folder_selected, &quot;output.csv&quot;)&#10;        returndf.to_csv(save_path, index=False)&#10;&#10;    return returndf&#10;&#10;&#10;def main():&#10;    # Load the criteria DataFrame from d:\rmflows folder&#10;    try:&#10;        criteria_path = &quot;D:/RMFLOWS/criteria.csv&quot;&#10;        criteria = pd.read_csv(criteria_path)&#10;&#10;        # Load the text DataFrame from d:\rmflows folder&#10;        text_path = &quot;D:/RMFLOWS/text.csv&quot;&#10;        text = pd.read_csv(text_path)&#10;    except Exception as e:&#10;        print(&quot;folder not present&quot;)&#10;    # Call rm_main function with the loaded dataframes&#10;    df = rm_main(criteria, text)&#10;&#10;    # Print the resulting DataFrame&#10;    print(df)&#10;&#10;&#10;# Call the main function&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;&#10;# Example usage:&#10;# criteria = ...  # Your DataFrame with criteria&#10;# text = ...  # Your DataFrame with text input&#10;# df = rm_main(criteria, text)&#10;"/>
        <parameter key="notebook_cell_tag_filter" value=""/>
        <parameter key="use_default_python" value="true"/>
        <parameter key="package_manager" value="conda (anaconda)"/>
        <parameter key="use_macros" value="false"/>
      </operator>
      <connect from_op="starter" from_port="arima" to_op="Install dependencies" to_port="input 1"/>
      <connect from_op="Install dependencies" from_port="output 1" to_op="Set key" to_port="input 1"/>
      <connect from_op="Set key" from_port="output 1" to_op="Criteria processing" to_port="input 1"/>
      <connect from_op="Criteria processing" from_port="output 1" to_op="Text processing" to_port="input 1"/>
      <connect from_op="Text processing" from_port="output 1" to_op="Apply criteria" to_port="input 1"/>
      <connect from_op="Text processing" from_port="output 2" to_op="Apply criteria" to_port="input 2"/>
      <connect from_op="Apply criteria" from_port="output 1" to_port="result 1"/>
      <portSpacing port="source_input 1" spacing="0"/>
      <portSpacing port="sink_result 1" spacing="0"/>
      <portSpacing port="sink_result 2" spacing="0"/>
    </process>
  </operator>
</process>
